"""
Includes functions related to the Playfair Cipher

generateGrid(keyword) creates the grid used for encoding/decoding
splitMessage(message) splits the message to be encoded into pairs and
                        inserts 'x' as needed
encodePlayfair(msg, key) encodes msg using a grid generated using key
decodePlayfair(cipher, key) decodes cipher using the grid generated using key
printGrid(keyword) prints the grid generated by keyword
"""
import re

#grid = [[], [], [], [], []]

def generateGrid(keyword):
    keyword = keyword.lower()
    grid = [[], [], [], [], []]
    usedLetters = []
    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i/j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

    for x in keyword:
        if x not in usedLetters:
            if x == 'i' or x == 'j':
                if 'i/j' not in usedLetters:
                    usedLetters.append('i/j')
            else:
                usedLetters.append(x)

    for x in alphabet:
        if x not in usedLetters:
            usedLetters.append(x)

    #create 5x5 grid
    for i in range(0, 5):
        for j in range(0, 5):
            grid[i].append(usedLetters.pop(0))

    return grid

def splitMessage(message):
    blocks = message
    blocks = blocks.replace(' ', '')
    blocks = re.findall('.?', blocks)
    i = 0
    j = 1
    if len(blocks) % 2 == 0:
        for x in range(1, (len(blocks)//2)+1):
            i = x*2-2
            j = x*2-1
            if blocks[i] == blocks[j]:
                blocks.insert(j, 'x')
    else:
        for x in range(1, (len(blocks)//2)):
            i = x*2-2
            j = x*2-1
            if blocks[i] == blocks[j]:
                blocks.insert(j, 'x')

    pairs = ""
    for c in blocks:
        pairs+=c

    pairs = re.findall('..?', pairs)

    for x in pairs:
        if len(x) == 1:
            pairs[pairs.index(x)] = x+'x'

    return pairs

def encodePlayfair(msg, key):
    grid = generateGrid(key)
    pairs = splitMessage(msg)
    message = msg.lower()
    keyword = key.lower()
    encoded = ""
    #intialize variables
    c1_yIndex = 0
    c2_yIndex = 0
    c1_xIndex = 0
    c2_xIndex = 0

    for p in pairs:
        c1 = p[0]
        c2 = p[1]

        for i in range(0, 5):
            for j in range(0, 5):
                if c1 == 'i' or c1 == 'j':
                    if grid[i][j] == 'i/j':
                        c1_yIndex = i
                        c1_xIndex = j
                elif grid[i][j] == c1:
                    c1_yIndex = i
                    c1_xIndex = j
                if c2 == 'i' or c2 == 'j':
                    if grid[i][j] == 'i/j':
                        c2_yIndex = i
                        c2_xIndex = j
                elif grid[i][j] == c2:
                    c2_yIndex = i
                    c2_xIndex = j

        newPair = ""

        if c1_yIndex == c2_yIndex: #if horizontally aligned
            if c1_xIndex == 4:
                newPair+=(grid[c1_yIndex][0])
            else:
                newPair+=(grid[c1_yIndex][c1_xIndex+1])
            if c2_xIndex == 4:
                newPair+=(grid[c2_yIndex][0])
            else:
                newPair+=(grid[c2_yIndex][c2_xIndex+1])

        elif c1_xIndex == c2_xIndex: #if vertically aligned
            if c1_yIndex == 4:
                newPair+=(grid[0][c1_xIndex])
            else:
                newPair+=(grid[c1_yIndex+1][c1_xIndex])
            if c2_yIndex == 4:
                newPair+=(grid[0][c2_xIndex])
            else:
                newPair+=(grid[c2_yIndex+1][c2_xIndex])
        else:
            newPair+=grid[c1_yIndex][c2_xIndex]
            newPair+=grid[c2_yIndex][c1_xIndex]

        encoded+=(newPair)
    print("Encoded ", encoded)
    return encoded

def decodePlayfair(cipher, key):
    grid = generateGrid(key)
    ciphertext = cipher.lower()
    keyword = key.lower()
    decoded = ""
    pairs = re.findall('..?', ciphertext)
    #initialize variables
    c1_yIndex = 0
    c2_yIndex = 0
    c1_xIndex = 0
    c2_xIndex = 0
    for p in pairs:
        c1 = p[0]
        c2 = p[1]
        for i in range(0, 5):
            for j in range(0, 5):
                if c1 == 'i' or c1 == 'j':
                    if grid[i][j] == 'i/j':
                        c1_yIndex = i
                        c1_xIndex = j
                elif grid[i][j] == c1:
                    c1_yIndex = i
                    c1_xIndex = j
                if c2 == 'i' or c2 == 'j':
                    if grid[i][j] == 'i/j':
                        c2_yIndex = i
                        c2_xIndex = j
                elif grid[i][j] == c2:
                    c2_yIndex = i
                    c2_xIndex = j

        newPair = ""

        if c1_yIndex == c2_yIndex: #if horizontally aligned
            if c1_xIndex == 0:
                newPair+=(grid[c1_yIndex][4])
            else:
                newPair+=(grid[c1_yIndex][c1_xIndex-1])
            if c2_yIndex == 0:
                newPair+=(grid[c2_yIndex][4])
            else:
                newPair+=(grid[c2_yIndex][c2_xIndex-1])

        elif c1_xIndex == c2_xIndex: #if vertically aligned
            if c1_xIndex == 0:
                newPair+=(grid[4][c1_xIndex])
            else:
                newPair+=(grid[c1_yIndex-1][c1_xIndex])
            if c2_yIndex == 0:
                newPair+=(grid[4][c2_xIndex])
            else:
                newPair+=(grid[c2_yIndex-1][c2_xIndex])
        else:
            newPair+=grid[c1_yIndex][c2_xIndex]
            newPair+=grid[c2_yIndex][c1_xIndex]

        decoded+=(newPair)

    decoded = decoded.replace("i/j", "[i/j]")
    return decoded


def printGrid(keyword):
    keyword = keyword.lower()
    grid = generateGrid(keyword)
    for i in range(0, 5):
        print(grid[i])
        
